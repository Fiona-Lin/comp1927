
<!-- saved from url=(0058)https://www.cse.unsw.edu.au/~cs1927/17x1/week03/Tut03.html -->
<html class="gr__cse_unsw_edu_au"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">

<title>Tute03 - 16x1 COMP1927</title>


<script src="./Tute03 - 16x1 COMP1927_files/common.js" type="text/javascript"></script>
<link rel="stylesheet" type="text/css" charset="utf-8" media="all" href="./Tute03 - 16x1 COMP1927_files/style.css">

   <link rel="stylesheet" type="text/css" charset="utf-8" media="all" href="./Tute03 - 16x1 COMP1927_files/msie.css">

</head><body data-gr-c-s-loaded="true"><div lang="en" id="content" dir="ltr"><span class="anchor" id="top"></span><span class="anchor" id="line-6"></span><span class="anchor" id="line-7"></span>
<p class="line867">

</p><h1> Tutorial Exercises Week 03 </h1>

<h2> Exercise 1 </h2>
<p> <strong> Function Growth Rates </strong></p>
<p>Calculate how long T(n) steps would take for different 
sizes of n for the T(n) functions in the table below.
Assume you are running it on a computer that performs one million steps 
per millisecond.
Note: A millisecond is a thousandth of a second. 
</p><p>
<table border="1" cellspacing="0" cellpadding="6">
<tbody><tr><th>n</th><th>T(n) = log n</th><th>T(n) = n</th><th>T(n) = n log n</th><th>T(n) = 
n<sup>2</sup></th><th>T(n) = n<sup>3</sup></th><th>T(n) = 2<sup>n</sup>
</th></tr><tr><th>10</th><td> </td><td> </td><td> </td><td> </td><td> </td><td>
</td></tr><tr><th>20</th><td> </td><td> </td><td> </td><td> </td><td> </td><td>
</td></tr><tr><th>50</th><td> </td><td> </td><td> </td><td> </td><td> </td><td>
</td></tr><tr><th>100</th><td> </td><td> </td><td> </td><td> </td><td> </td><td>
</td></tr><tr><th>1000</th><td> </td><td> </td><td> </td><td> </td><td> </td><td>
</td></tr><tr><th>10000</th><td> </td><td> </td><td> </td><td> </td><td> </td><td>
</td></tr></tbody></table>
</p><p>For what size of n does the computation time for T(n) = 2<sup>n</sup> 
become too large to be practical?  Would it help if we used a computer 
that was a million times faster?

</p><h2> Exercise 2 </h2>
<p>Write a recursive function </p>
<pre>int allEven (int a[], int l, int r);
</pre>
<p>
which takes an array, the left-most and right-most index of the current 
segment of the array as an argument and checks if all elements in an array are 
even. 
</p><p>It must use a divide and conquer approach, by splitting the array in 
half, first checking if all the 
elements in the left half are even, and 
then (only if necessary) checking the right half. 
</p><p>What would the worst-case time complexity be in Big O notation?

</p><h2> Exercise 3 </h2>
<p><strong> Binary Search Tree Insertion, Deletion and Traversal</strong>
</p><p> Insert the following keys into a BST:&nbsp; 10 20 5 30 15 25 24
</p><p>What is the height of the resulting tree?
</p><p> Delete 5 30 20 (assume we replace nodes with the left-most of the 
right sub-tree when necessary)
</p><p>What is the height of the resulting tree?

</p><p class="line874">Show the output obtained by traversing the tree and
printing out <span class="anchor" id="line-20"></span>each node in the
following orders:
<span class="anchor" id="line-21"></span></p>
<ul><li>prefix (NLR) <span class="anchor" id="line-22"></span></li><li>postfix (LRN) <span class="anchor" id="line-23"></span></li><li>infix (LNR) <span class="anchor" id="line-24"></span></li></ul>
<p class="line867"><span class="anchor" id="EndEx1"></span> <span class="anchor" id="line-25"></span><span class="anchor" id="line-26"></span></p><p class="line867">
</p>

<h2> Exercise 4 </h2>
<p><strong>BST Functions</strong></p>
<p>Assume the following representation of a BST</p>
<pre>typedef struct treenode *treelink;

struct treenode{
    Item item;
    treelink left;
    treelink right;
}

</pre>
<ul>
<li><p>Assume that you have <strong>Queue</strong> and <strong>Stack</strong> ADTs available.  Discuss how these ADTs may be
used to implement a non-recursive pre-order traversal and a non-recursive level-order reversal.

</p></li><li><p>Assume your tree holds items of type int. Write a function to recursively 
sum the items of a BST tree. Your 
function should have the following prototype:
</p><pre>int sumItems(treelink tree);
</pre>
</li><li><p>
Write a function that searches for a given item in a BST. Your   
function should return 1 if the item is found and 0 otherwise. You
should use an iterative approach and a recursive approach </p><p>
</p><pre>int iterativeSearch(treelink t, Item i);
</pre>
<pre>int recursiveSearch(treelink t, Item i);
</pre>
</li><li><p>
Write a function that will free all the memory associated with a tree
</p><pre>void freeTree(treelink t);
</pre>
</li><li>
<p>Write a function to insert an item into a BST. It should return the 
root of the tree.

</p><pre>treelink insert(treelink t, Item i);
</pre>

<p>
</p></li></ul>

</div>

</body><span class="gr__tooltip"><span class="gr__tooltip-content"></span><i class="gr__tooltip-logo"></i><span class="gr__triangle"></span></span></html>
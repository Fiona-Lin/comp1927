<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html><head>


<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<meta name="robots" content="noindex,nofollow">

<title>Tute05 - 17x1 COMP1927 </title>
<script type="text/javascript" src="../StyleGuide_files/common.js"></script>


<link rel="stylesheet" type="text/css" charset="utf-8" media="all" 
href="../style.css">

<!-- css only for MSIE browsers -->
<!--[if IE]>
   <link rel="stylesheet" type="text/css" charset="utf-8" media="all" href="/~cs1921cgi/wiki-shared/htdocs/modern/css/msie.css">
<![endif]-->


<h1 id="head-c4ae72924d158947b2cf3b7a412be366ae799569">Tutorial Week 05 - Graph Implementations</h1>


<H2>Exercise 1</H2>
<p>
<p>In lectures we have looked at two different implemtations of graphs. Adjacency matrices and adjacency lists. See representations below:
<p>
<PRE>
//Graph.h definitions
// vertices denoted by integers 0..N-1 
typedef struct graphRep * Graph;
typedef int Vertex; 
typedef struct edge Edge;

// edges are pairs of vertices (end-points) 
struct edge { 
    Vertex v; 
    Vertex w; 
} ;
</PRE>

<PRE>
//Adjacency matrix unweighted graph representation

struct graphRep { 
    int nV;        // #vertices 
    int nE;       // #edges 
    int **adj; // matrix of booleans (0 or 1)
}; 
</PRE>

<PRE>
//Adjacency list graph representation
typedef struct vNode *VList;
struct vNode { 
    Vertex v; 
    VList next; 
}; 

struct graphRep { 
    int nV; // #vertices 
    int nE; // #edges VList 
    VList *adj; // array of lists 
};
</PRE>

Show how the following graph could be stored using the given representations.

<H2>Exercise 2</H2>
<p>
Implement a function that tests whether a given graph edge is present in the graph. The 
function should return 1 if the edge exists in the graph and 0 otherwise.  Use the following prototype.
Implement the function for both the adjacency-matrix and the adjacency-list representations.</p>
<PRE> int isEdgeInGraph (Graph G, Edge e); </PRE>

<H2> Exercise 3 </H2>
<p> How could you change the implementations in Exercise 1 to represent a weighted graph with weights of type int? Would your implementations of isEdgeInGraph need to change?
</p>


<H2>Excercise 4</H2>
The following edges function is designed so that it simply requires a <tt>Graph</tt> as its parameter
and then returns both the array and a count of the number of edges.

<pre>
Edge *edges(Graph g, int *nE) { ... }
<span class="comment">// which would be used as ...</span>
Edge *es;  int n;   es = edges(g, &n);
</pre>
<p>
Implement this <tt>edges()</tt> function for each of the two
<tt>Graph</tt> representations. It should return the edges in
normalised/canonical form (e.v &lt; e.w), so that each edge appears exactly
once in the result array.
</p>

<h2> Exercise 5</h2>
<p>
Consider the adjacency matrix and adjacency list representations for graphs.
Analyse the storage costs for the two representations in terms of the number
of vertices <i>V</i> and the number of edges <i>E</i> and determine roughly
the point at which it is more storage efficient to use an adjacency matrix
representation vs the adjacenty list representation.
</p>
<p>
For the purposes of the analysis, ignore the cost of storing the
<tt>GraphRep</tt> structure. Assume that: each pointer is 4 bytes
long, a <tt>Vertex</tt> value is 4 bytes a linked-list <i>node</i> is
8 bytes long, that the adjacency matrix is a complete <i>V</i>&times;<i>V</i>
matrix, and each adjacency matrix element is 1 byte long (<tt>bool</tt>).
</p>

<h2>Exercise 6</h2>

<p>
For the following graph:
</p>
<center><img src="graph1.png"></center>
<p>
give examples of the smallest and largest of each of the following:
</p>
<ol type='a'>
<li> path
<li> cycle
<li> spanning tree
<li> clique
</ol>

</body></html>

